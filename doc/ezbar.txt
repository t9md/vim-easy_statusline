*ezbar.txt* statusline configuration helper for minimalist.

Version: 0.8
Author : t9md <taqumd@gmail.com>
GitHub : https://github.com/t9md/vim-ezbar
==============================================================================
CONTENTS					*ezbar-contents*

Introduction				    |ezbar-introduction|
Mapping					    |ezbar-mapping|
Commands				    |ezbar-commands|
Variables				    |ezbar-variables|
Functions				    |ezbar-functions|
Configuration Example			    |ezbar-example|
Bug					    |ezbar-bug|
Todo					    |ezbar-todo|
Changelog				    |ezbar-changelog|

==============================================================================
INTRODUCTION					*ezbar-introduction*

What's this?~
statusline configuration helper for minimalist.

Feature~
- No fancy colorscheme
- Simple design, easy to configure for vim-scripter(advanced user), no
  fail-safe guared for begginer
- Dynamically configure color based on condition.
- All statusline component(part) is implemented as dictionary function.
- No precedence to predefined parts, so it's up to you how organize your
  statusline.

==============================================================================
MAPPINGS					*ezbar-mappings*

==============================================================================
COMMANDS						*ezbar-commands*

*:EzBarDisable*
*:EzBarEnable*
	See corresponding |ezbar-functions|.

							*:EzBarColorCheck*
{range}:EzBarColorCheck
	Useful while you are trying to customize color.
	Temporarily highlight selected reange of lines like following color
	coonfiguration. Its' just helper setup helper, not essential part of
	this plugin.
>
      \ { 'chg_color': {'gui': [ s:bg, 'gray61'], 'cterm': [240, 254] }},
<
==============================================================================
VARIABLES						*ezbar-variables*

							      *g:ezbar_enable*
g:ezbar_enable
	Default: 1
	Type:    |Number|
	Set 0 to disable.
								     *g:ezbar*
g:ezbar
	Default: {}
	Type:    |Dictionary|
	All configuration belongs this Dictionary.

							     *g:ezbar._init()*

------------------------------------------------------------------------------
*ezbar-auto-variable*

Each time ezbar generate &statusline and before calling each parts function.
ezbar automatically set special variable for convenience.
All of these automatic variable name began double underscore.
So user should not use these name as parts name to avoid conflict.


 | varname    | brief description                                     | 
 | ---------- | ----------------------------------------------------- | 
 | __active   | indicate active window or not                         | 
 | __mode     | result of mode()                                      | 
 | __width    | winwidth                                              | 
 | __filetype | filetype                                              | 
 | __buftype  | buftype                                               | 
 | __parts    | normalized part with parts name as key                | 
 | __layout   | layout specified as g:ezbar.active or inactive        | 
 | __color    | indicate current default color set to part            | 
 | __colors   | color collections you specify as g:ezbar.colors       | 
 | __         | helper function collection                            | 

{PARTS}.__active	|Number|: ( 0 or 1 ). Indicate active window or not.
{PARTS}.__mode		|String|:  result of |mode()|
{PARTS}.__width		|Number|: result of |winwidth()|
{PARTS}.__filetype	|String|: |&filetype|
{PARTS}.__buftype	|String|: |&buftype|
{PARTS}.__parts
	Type: |Dictionary|
	{key}:		part function name.
	{value}:	normalized part.
	usefull to directly access other part's attribute like 's' or 'c'.

{PARTS}.__layout   
	Type: |List|
	Layout is the list you specified in g:ezbar.active or inactive.
	At start(of each status line refresh), ezbar copy these list and
	transform each part_name string into normalized part.
	So you can manupilate this layout within |_init()| hook.
	You can modify this variable to manupilate layout.

	Example: hide some parts when winwidth is narrow~
>
	function! g:ezbar._init(_)
	  if self.__is_active
	    let hide = []
	    if winwidth(0) < 80
	      let hide += self.__layout[-3:]
	    endif
	    if winwidth(0) < 30
	      call add(hide, 'filename')
	    endif
	    call filter(self.__layout, 'index(hide, v:val) == -1')
	  endif
	endfunction
<

{PARTS}.__color    
	Type: |Dictionary| or |String|
	Represent current color which is used for un colorized part.

{PARTS}.__colors   
	Type: |Dictionary|
	Color collection table used to dynamically modify color within
	part-function.

{PARTS}.__         
	Type: |Dictionary|
	Collection of helper function.


------------------------------------------------------------------------------
*ezbar-hook*

{PARTS}._init({winnum})
	Default: Not Defined
	Type:    |Function|

	Called at very first timing before each parts-function is called.

{PARTS}._parts_missing({winnum}, {partname})
	called when partname part-function not found.

{PARTS}._finish({winnum})

==============================================================================
FUNCTIONS						*ezbar-functions*

ezbar#enable()
ezbar#disable()
	Enable or disable ezbar. Useful while try&error for customizing.

ezbar#string({active}, {winnum})
	Return string that represent |statusline|.
	{active}: 0 or 1
	{winnum}: |winnum()|for target window.

ezbar#set()
	Set &satusline with the result of |ezbar#string()|.
	Called every timing needed to refresh |statusline|.

==============================================================================
CONFIGURATION EXAMPLE				    *ezbar-example*

See README.md for complete example.

==============================================================================
BUG							    *ezbar-bug*

==============================================================================
TODO							    *ezbar-todo*

[ ] arg type passed to parts function should |Dictionary|?
    Its resilient to change. adding another argument as new dict field is not
    affect to existing user.
[ ] Depelicate to store highlight name directry or internaly convert to
    dictionary before store, to avoid type mismatch error when modify color.
    [Strategy] hl#register() if arg is str, cature hl def then convrt to dict.
    This elminate tedious unlet clause to avioid type error.
    Need re-capture/redefine when refresh()
[ ] Can refer total display length from each parts. total len() of s fields.
    This helps to determine show/hide within each parts.
[ ] allow access to preceding normalized parts from later parts.
    this allow right parts decide color, besed on color of left parts
[ ] introduce way to change partial color like only fg, only bg, reverse
    like empty field respect default color ['', 'yellow' ]
[x] LeafCage: want to change default color in parts-function()
[x] LeafCage: reduce type() call
[x] LeafCage: default self.color_active is not used?
[x] LeafCage: _init(), pass winnum as argument
[x] itchyny: care other tab in ezbar#disable()

==============================================================================
CHANGELOG						*ezbar-changelog*
2014-01-16:
	- catch error in parts and notify within parts.
2014-01-15:
	- change command name of :EzBarCheckHighlight to :EzBarColorCheck
2014-01-14:
	- [change] '__is_active' now '__active'
	- [behaveChange] disastrous behavior change eliminate { 'chg_color': }
	  , { '__SEP__': }
	- [new] add _parts_missing() special hook
2013-12-28:
	- [experiment] now __layout is to modify in _init()
	- [experiment] set __default_color parts variable.
	- [bugfix] initalize timing for self.color_active/color_inactive.
	- [experiment] add new argument to _init() which is |winuum()|of
	  target window, suggested by LeafCage.
2013-12-27:
	- reduce type() call for performance and readability suggested by
	  LeafCage.
2013-11-21:
	- initial release.
==============================================================================
vim:tw=78:ts=8:ft=help:norl:
